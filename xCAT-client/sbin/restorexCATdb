#!/usr/bin/perl
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html
#(C)IBM Corp

#

BEGIN
{
    $::XCATROOT =
        $ENV{'XCATROOT'} ? $ENV{'XCATROOT'}
      : -d '/opt/xcat'   ? '/opt/xcat'
      : '/usr';
}
use lib "$::XCATROOT/lib/perl";
use Getopt::Long;
use xCAT::MsgUtils;
use xCAT::Utils;
use strict;

#-----------------------------------------------------------------------------

=head1  restorexCATdb 



 restorexCATdb  -p <directory containing db restore .csv files> 


=cut

#-----------------------------------------------------------------------------
# Main
my $rc = 0;

&parse_args;

# read all the *.csv files from the input directory and restore the database
opendir DIRPATH, $::PATH;
if ($? != 0)
{
    my $msg = " Unable to read directory $::PATH \n";
    xCAT::MsgUtils->message("E", $msg);
    exit 1;
}
# read tables to skip during restore from site.skiptables attribute
my @output2=xCAT::Utils->get_site_attribute('skiptables');
my @skiptbls;
if (@output2) {
  @skiptbls = split (/\,/,$output2[0]);
}

my @files = readdir(DIRPATH);
foreach my $table (@files)
{
    if ($table ne '.' and $table ne '..')
    {
        my $tablename = $::PATH;
        $tablename .= "/";
        $tablename .= $table;
        if ( (!$::ALL) && (($table =~ /^eventlog/) || ($table =~ /^auditlog/))) {
            
          if ($::VERBOSEREST) {
            xCAT::MsgUtils->message("I", "Skipping $table\n");
          }
          next;
        }
        # skip teal tables
        if ( $table =~ /^x_teal/ ) {
           if ($::VERBOSEREST) {
            xCAT::MsgUtils->message("I", "Skipping $table\n");
           }
           next;
        }
        # skip ISNM tables except isnm_config
        if ( $table =~ /^isnm_perf/ ) {
          if ($::DUMPVERBOSE) {
            xCAT::MsgUtils->message("I", "Skipping $table\n");
          }
          next;
        }

        # skip and table in the site.skiptables attribute
        if (@skiptbls) {
          my ($tmptable,$suffix) = split(/\./,$table);
          chomp $tmptable;
          if (grep(/^$tmptable$/, @skiptbls)) {
            if ($::VERBOSEREST) {
             xCAT::MsgUtils->message("I", "Skipping $tmptable\n");
            }
             next;
          }
        }

        my $cmd = "tabrestore $tablename";
        my @errout = xCAT::Utils->runcmd($cmd, 0);
        if ($::RUNCMD_RC != 0)
        {    # error
            xCAT::MsgUtils->message("E", "Error running $cmd, @errout\n");
        } else {
          if ($::VERBOSEREST) {
            xCAT::MsgUtils->message("I", "Restoring $table.\n");
          }
        }
    }
}
closedir DIRPATH;
xCAT::MsgUtils->message("I", "Restore of Database Complete.");
exit $rc;

#-----------------------------------------------------------------------------

=head3 parse_args
  
  Parses for  input

=cut

#-----------------------------------------------------------------------------
sub parse_args
{
    my $msg;
    my    $usagemsg =
          " restorexCATdb  -h \n restorexCATdb -v \n restorexCATdb [-a] [-V] <-p> [path to restore .csv files]\n";
    Getopt::Long::Configure("posix_default");
    Getopt::Long::Configure("no_gnu_compat");
    Getopt::Long::Configure("bundling");
    if (
        !GetOptions(
            'a|all'  => \$::ALL,
            'p|path=s'  => \$::PATH,
            'h|help'    => \$::HELP,
            'V|verbose'    => \$::VERBOSEREST,
            'v|version' => \$::VERSION

        )
      )
    {
        xCAT::MsgUtils->message("E", $usagemsg);
        exit 1;
    }
    if ($::HELP)
    {
        xCAT::MsgUtils->message("I", $usagemsg);
        exit 0;
    }
    if ($::VERSION)
    {
        my $version = xCAT::Utils->Version();
        xCAT::MsgUtils->message("N", $version);

        exit 0;
    }
    if (!($::PATH))
    {
        my $msg = " -p with path to database files is required \n";
        xCAT::MsgUtils->message("E", $msg);
        exit 1;
    }
    if (!(-e $::PATH))
    {
        my $msg = " Input path must exist \n";
        xCAT::MsgUtils->message("E", $msg);
        exit 1;
    }

}

