#!/usr/bin/perl

# NOTE: this cmd is not ported to xCAT 2.0 and is not used any more!!!!!!

# Display some aggregate information about each group, gathered from the db and its nodes

use strict;
use Getopt::Std;

sub usage { print "Usage: grpattr [-h] [-v]\n";  exit (scalar(@_) ? $_[0] : 1); }

if (! getopts('hv') ) { usage(); }
if ($::opt_h) { usage(0); }
#if (scalar(@ARGV) < 1) { &usage; }
#$::VERBOSE = $::opt_v;

# Get the status of each node and save in a hash
my @ns = runcmd("nodestat '/.*'");
my %nodestat;
foreach my $line (@ns) {
	my ($node, $stat) = split(/[:\s]+/, $line);
	$nodestat{$node} = $stat;
}
if ($::opt_v) { foreach my $n (keys %nodestat) { print "$n: $nodestat{$n}\n"; } }


# Get the list of nodes/groups and aggregate the status of the group using the status of each node
#TODO: this must be changed for xcat 2.0
my @nodelist = runcmd("egrep '^[A-Za-z]' $ENV{XCATROOT}/etc/nodelist.tab");
verbose("Found ", scalar(@nodelist), " items in nodelist.tab\n");
my %groups;
foreach my $line (@nodelist) {
	my ($node, $groupstr) = split(/\s+/, $line);
	my @grouplist = split(/[,\s]+/, $groupstr);
	foreach my $g (@grouplist) {
		$groups{$g} = minstat($groups{$g}, $nodestat{$node});
	}
}
foreach my $g (keys %groups) { print "$g: $groups{$g}\n"; }

exit;

# For 2 status strings from nodestat, return the "lowest".
sub minstat {
	my %statnum = ( 'unknown' => 0,
					'noping' => 1,
					'ping' => 2,
					'snmp' => 3,
					'sshd' => 4,
					'pbs' => 5,
					'ready ww' => 6
					);
	my %statstr = ( 0 => 'unknown',
					1 => 'noping',
					2 => 'ping',
					3 => 'snmp',
					4 => 'sshd',
					5 => 'pbs',
					6 => 'ready ww'
					);
	my ($s1, $s2) = @_;

	# if either value is empty, just return the other one
	if (!length($s1)) { return $s2; }
	if (!length($s2)) { return $s1; }

	my $n1 = defined($statnum{$s1}) ? $statnum{$s1} : 0;
	my $n2 = defined($statnum{$s2}) ? $statnum{$s2} : 0;
	if ($n1 < $n2) { return $statstr{$n1}; }
	else { return $statstr{$n2}; }
}

# Assign a numerical order number to each status string
sub statnum {
	my $s = shift @_;
	if ($s eq 'noping') { return 1; }
	elsif ($s eq 'ping') { return 2; }
}

sub runcmd {
	my $cmd = shift @_;
	my @out = `$cmd`;
	my $rc = $? >> 8;
	if ($rc) { print join('',@out); return; }
	chop(@out);
	return @out;
}

sub verbose { if ($::opt_v) { print @_; } }
